[{"content":"目的 快速创建 github 或者 gitlab 仓库，只使用命令行 gh 和 glab 的官方 cli 工具 安装 macOS 1 2 brew install gh brew install glab 命令 认证 1 gh auth login 这里去 token页面 创建所需 scopes 的 token\n1 glab auth login gitlab 如果是自建的可以选择自定义 hostname\n显示信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 列出repo信息 gh repo list glab repo list ## gitlab 如果是自建的，执行前先把host设为你自建的, -g为全局 glab config set -g host xxxx.xxxx.com # 搜索 ## 搜索名为xxx的库 glab repo search -s xxx # 查看项目的README信息 gh repo view glab repo view 创建与变更仓库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 # 克隆下某个仓库 gh repo clone xxx/xxxx glab repo clone xxx/xxxx glab repo clone https://xxxxx glab repo clone [id] # 创建 ## gh ### 此时目录下有个test-create-repo目录，test-create-repo 已经是个git仓库 ### 将 test-create-repo 以私有的形式推送到github，此时gh会在远程创建一个test-create-repo的仓库 gh repo create --private --source=test-create-repo --push ### 创建一个 test-repo-create2 私密仓库，添加readme和描述，如下图。并克隆到本地 gh repo create test-repo-create2 -c --private --add-readme -d \u0026#34;测试远程仓库创建并克隆到本地\u0026#34; ## glab ### 在个人空间下创建私密仓库，create后面为路径以及在当前目录下的目录 glab repo create test-create-repo --private -n test-create-repo -d \u0026#34;测试在个人空间下创建私密仓库\u0026#34; ### 指定 组/空间 glab repo create test-create-repo -n test-create-repo -g xxx -d \u0026#34;测试在xxx组下创建仓库\u0026#34; ### 进入git目录 glab repo create -n test-create-repo -d \u0026#34;描述\u0026#34; # 同步上游（如果fork其他仓库） gh repo sync shelken/test-create-repo # 改变仓库的可见 ## 将当前目录对应仓库转为公开 gh repo edit --visibility public ## 将指定仓库的可见性转为私密 gh repo edit shelken/test-create-repo --visibility private # 删除 gh repo delete --yes gh repo delete xxx/xxxx --yes ## 指定 空间/repo 删除 glab repo delete xxx/xxxx -y ## 指定 本人/repo 删除 glab repo delete xxxx -y ## 本目录对应repo删除 glab repo delete -y ","date":"2024-01-19T20:05:42+08:00","image":"https://cdn.jsdelivr.net/gh/shelken/picbed/uPic/2025-03/4uQN13-1qOq7y.png","permalink":"https://blog.ooooo.space/p/gh_glab/","title":"gh/glab 命令快速上手"},{"content":" 这个项目帮助你：不需要配置复杂的配置；使用 git 来同步你的配置；及时地更新社区维护的词库\n仓库地址Rime auto deploy\n可以在项目的 readme 了解基本的用法，例如安装，升级等操作。这里我主要就常用的几个操作进行介绍来快速入门。\n安装到你的新设备 在进行安装前，你应该将这个项目 fork 下来，方便我们后续的修改配置和同步配置\n这里你只需要看项目的操作\nMacOS/Linux 使用方法 这里告诉你基本的在新的设备上安装操作。记得 clone 自己的项目地址 配置 流程 当你需要自定义一些配置时，你只需要关注一个目录，那就是 custom 目录\n修改在 custom 目录下的配置文件 重新运行 installer. rb ，选 2 手动模式，再选 4，复制你的配置到 rime 的配置。 然后重新部署 rime。快捷键 alt + ctrl + ` git add commit push 切换你的输入方案 如果你是个双拼用户，那么可以按 ctrl + ` 来让切换你的双拼方案\n切换输入法时保存已经输入的字符 有时候，在输入中文时突然想要切换到英文。我的习惯是直接按右 Shift 来切换，但是初次使用时发现已经输入的字被清除了，这个时候需要在 custom/default.custom.yaml 去修改 在你的 switch_key.Shift_R 下，从 clear 改为 commit_code\n在不同的应用中自动切换为中文或者英文输入法 在 custom/squirrel.custom.yaml 中添加你所安装的应用的配置，如下：\n不同设备同步词库 在你的 /Users/[yourname]/Library/Rime 目录下应该有 installation.yaml 文件，编辑它，将 installation_id 改为你喜欢的任意唯一的名，例如当前设备的名。在文件末尾加上 sync_dir: \u0026quot;xxxx\u0026quot; ，xxxx 为你需要存放的目录，例如 iCloud 云目录。保存后，点击同步用户数据，即可在存放的目录下看到 installation_id 为名的目录。\n参考 我的配置 雾凇拼音配置 ️ ","date":"2023-11-19T21:21:57+08:00","image":"https://cdn.jsdelivr.net/gh/shelken/picbed/uPic/2023-11/kFmrVz.png","permalink":"https://blog.ooooo.space/p/%E7%AE%80%E5%8D%95%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%BC%80%E6%BA%90%E7%9A%84%E8%BE%93%E5%85%A5%E6%B3%95-rime/","title":"简单地使用开源的输入法 rime"},{"content":"众所周知，headscale 可以解决 Tailscale 的一些限制，例如设备数。但是 headscale 部署需要一个公网 IP。最近，Tailscale 的 Funnel 进入 beta 测试了，刚好又看到一个大佬写了一篇利用 Tailscale 的 Funnel，将本地部署的 headscale 开放到公网的文章 Using Tailscale without using Tailscale。这意味着我们可以使用 Tailscale 让人们通过互联网访问我们搭建的 headscale，并且只使用 headscale 来让设备加入节点。感觉有点像背叛 Tailscale 官方啊，可怜三秒。\n接下来简单介绍一下操作步骤。\n先在任意一台自己的本地机器起一个最新稳定版 Tailscale。 安装命令\n1 curl -fsSL https://tailscale.com/install.sh | sh 再起一个 headscale，这里我用 docker-compose 部署，这里我大部分参考了官方的教程 另外，单独起了一个 webui 方便查看 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 version: \u0026#39;3.8\u0026#39; services: headscale: image: \u0026#39;headscale/headscale:latest\u0026#39; container_name: headscale volumes: - /data/docker/headscale/config:/etc/headscale/ environment: - TZ=Asia/Shanghai ports: - \u0026#39;9090:9090\u0026#39; - \u0026#39;8080:8080\u0026#39; restart: always command: headscale serve headscale-webui: image: ghcr.io/ifargle/headscale-webui:latest container_name: headscale-webui restart: always ports: - \u0026#39;8083:5000\u0026#39; environment: - TZ=Asia/Shanghai - COLOR=red # Use the base colors (ie, no darken-3, etc) - - HS_SERVER=http://headscale:8080 # Reachable endpoint for your Headscale server - DOMAIN_NAME=http://headscale-webui:5000 # The base domain name for this container. - SCRIPT_NAME=/admin # This is your applications base path (wsgi requires the name \u0026#34;SCRIPT_NAME\u0026#34;). Remove if you are hosing at the root / - KEY=\u0026#34;\u0026#34; # Generate with \u0026#34;openssl rand -base64 32\u0026#34; - used to encrypt your key on disk. - AUTH_TYPE= # AUTH_TYPE is either Basic or OIDC. Empty for no authentication - LOG_LEVEL=info # Log level. \u0026#34;DEBUG\u0026#34;, \u0026#34;ERROR\u0026#34;, \u0026#34;WARNING\u0026#34;, or \u0026#34;INFO\u0026#34;. Default \u0026#34;INFO\u0026#34; # ENV for Basic Auth (Used only if AUTH_TYPE is \u0026#34;Basic\u0026#34;). Can be omitted if you aren\u0026#39;t using Basic Auth - BASIC_AUTH_USER=user # Used for basic auth - BASIC_AUTH_PASS=pass # Used for basic auth # ENV for OIDC (Used only if AUTH_TYPE is \u0026#34;OIDC\u0026#34;). Can be omitted if you aren\u0026#39;t using OIDC - OIDC_AUTH_URL=https://auth.$DOMAIN/.well-known/openid-configuration # URL for your OIDC issuer\u0026#39;s well-known endpoint - OIDC_CLIENT_ID=headscale-webui # Your OIDC Issuer\u0026#39;s Client ID for Headscale-WebUI - OIDC_CLIENT_SECRET=YourSecretHere # Your OIDC Issuer\u0026#39;s Secret Key for Headscale-WebUI volumes: - /data/docker/headscale/web-ui/data:/data # Headscale-WebUI\u0026#39;s storage. Make sure ./volume is readable by UID 1000 (chown 1000:1000 ./volume) - /data/docker/headscale/config/:/etc/headscale/:ro # Headscale\u0026#39;s config storage location. Used to read your Headscale config. 然后执行 Tailscale funnel 命令，将 headscale 开放到公网 1 2 3 4 tailscale serve tls-terminated-tcp:443 tcp://127.0.0.1:8080 tailscale funnel 443 on # 证书认证 tailscale cert [被分配的domain] 其他客户端使用 ios 端现在已经也可以自定义 login-server，在设置里面填入自己的 headscale 地址 其他端直接命令\n1 tailscale login --login-server https://xxx.xxx.ts.net ","date":"2023-04-05T17:12:29+08:00","image":"https://cdn.jsdelivr.net/gh/shelken/picbed/uPic/2023-11/gyzvPb.png","permalink":"https://blog.ooooo.space/p/%E5%9C%A8%E4%B8%8D%E7%94%A8tailscale%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%BF%E7%94%A8tailscale/","title":"在不用Tailscale的情况下使用Tailscale"},{"content":"测试 测试\nTo run this asciicast without javascript, use asciinema play https://asciinema.org/a/564652.cast with Asciinema\n","date":"2023-03-05T03:04:46+08:00","image":"https://cdn.jsdelivr.net/gh/shelken/picbed/uPic/2023-11/hqH7rN.png","permalink":"https://blog.ooooo.space/p/asciinema%E7%9A%84%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8/","title":"Asciinema的初次使用"},{"content":"材料 Episode-ReName（以下简称 er） qBittorrent（以下简称 qb） 背景 很多字幕组种子的命名格式往往不是按照SxxExx的格式来命名的，而 Emby，Plex 等媒体服务器都是以识别SxxExx来刮削剧集的元数据。因此为了让这些媒体服务器识别剧集，我们往往需要重命名下载的文件。\n期望 qb 下载剧集后，自动将不符合的资源名命名为形如'剧集名 - SxxExx.mp4'\n实践 流程 克隆 er 源代码,使用 pyinstaller 将 EpisodeReName.py 编译成可执行程序。（作者在原仓库有提供 windows 的，win 用户可以直接下载使用，我是 linux 环境，因此自己编译）,将可执行程序放到你想要它在的文件夹下面（我直接上传群晖下的文件夹） 设置 qb 下的「Torrent 完成时运行外部程序」，填入程序路径和必要参数 编译可执行程序 win 用户跳过此步骤，直接在原仓库下载作者提供的程序；linux 用户可以直接在本地使用 pyinstaller 来操作编译（docker 也行）。如果是 mac 用户则可以使用 docker 镜像来编译 linux 程序。m1 用户建议换台电脑，目前 docker 镜像编译有问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 cd /你的工作目录 # 拉取源代码 git clone https://github.com/Nriver/Episode-ReName.git cd Episode-ReName # 安装所需 requirements （requirements中包含了pyinstaller，如果是docker编译，可以把pyinstaller去掉） pip3 install -r requirements.txt # 编译（非docker方式） pyinstaller -F EpisodeReName.py # 编译（docker方式） docker run -v \u0026#34;$(pwd):/src/\u0026#34; cdrx/pyinstaller-linux # 移动编译后程序到你想要的文件夹。 mv ./dist/linux/EpisodeReName anywhere # 我是在mac上编译的，因此把它复制到我的群晖上 scp ./dist/linux/EpisodeReName shelken@192.168.0.80:/volume1/docker/qb-web/script/Episode-ReName/dist/EpisodeReName 设置 qb 执行程序 打开工具-\u0026gt;选项-\u0026gt;下载。开启「Torrent 完成时运行外部程序」，填入你的程序地址\n参数解释：\n1 2 3 4 5 6 7 8 qb参数： %F：如果种子是单文件的，那么输出则为：/保存路径/xxxxx.mp4；如果是多文件。那么则会是: /保存路径/根目录名。 er参数：（这部分详细可以去看原文档，这里只介绍我使用的） --path：目标路径，可以是单文件，可以是目录，目录会处理所有该目录下文件 --delay: 延迟多久操作，默认为0秒不等待，这个参数主要是配合qbitorrent使用, 避免qb锁定文件导致重命名失败. 一般停止做种15秒后在操作能确保文件被释放 --name_format：自定义重命名格式, 参数需要加引号 默认为 \u0026#34;S{season}E{ep}\u0026#34; 可以选择性加入 series系列名称 如 \u0026#34;{series} - S{season}E{ep}\u0026#34;。这里我使用了第二种格式。 举例: /volume1/docker/qb-web/script/Episode-ReName/dist/EpisodeReName --path=\u0026#34;%F\u0026#34; --delay=15 --name_format=\u0026#34;{series} - S{season}E{ep}\u0026#34; 技巧 查看 qb 日志 1 2 # volume1：取决于你套件安装在哪个存储空间 cat /volume1/\\@appstore/qBittorrent/qBittorrent_conf/data/logs/qbittorrent.log 给可执行程序赋权 1 2 3 # 如果不能执行程序，尝试给EpisodeReName执行程序赋予可执行权限 chmod +x /所在目录/EpisodeReName # 多季番剧tmdb集数适配 对于有多季的番剧, 比如鬼灭之刃28集, 在tmdb里没有第28集, 而是第2季第2集, 要正确削刮需要从S02E28改成S02E02.\n这时候可以在鬼灭之刃的Season 2文件夹中添加一个all.txt文件, 里面写上一个数字, 会在自动重命名的时候减掉这个数字. 比如上面的例子就需要在all.txt填入26, 自动重命名就会把S02E28改成S02E02, 这样就能正常削刮了.\n注意 文件夹命名格式 剧名和季数是根据文件夹命名来识别的，集数是根据文件名的数字。\n剧名与季数 形如：/剧集目录/剧名/Season 1/\n季数命名格式要求：Season1 / Season 1 / s1 / S1\n举例：/volume1/Video/watch/夏日重现/s1\n集数 形如：/剧集目录/剧名/Season 1/xxxx[01]xxxxxx.mp4\n集数命名匹配的正则：会匹配在括号（各种括号）内的数字，数字规则如下，以找到的第一个符合项作为集数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 patterns = [ # 1到4位数字 \u0026#39;(\\d{1,4}(\\.5)?)\u0026#39;, # 特殊文字处理 \u0026#39;第(\\d{1,4}(\\.5)?)集\u0026#39;, \u0026#39;第(\\d{1,4}(\\.5)?)话\u0026#39;, \u0026#39;第(\\d{1,4}(\\.5)?)話\u0026#39;, \u0026#39;[Ee][Pp](\\d{1,4}(\\.5 \u0026#34;Ee][Pp\u0026#34;)?)\u0026#39;, \u0026#39;[Ee](\\d{1,4}(\\.5 \u0026#34;Ee\u0026#34;)?)\u0026#39;, # 兼容SP01等命名 \u0026#39;[Ss][Pp](\\d{1,4}(\\.5 \u0026#34;Ss][Pp\u0026#34;)?)\u0026#39;, # 兼容v2命名 \u0026#39;(\\d{1,4}(\\.5)?)[Vv]?\\d?\u0026#39;, ] 举例:\n1 2 # 输入：/volume1/Video/watch/夏日重现/s1/[Nekomoe kissaten][Summer Time Rendering][05][1080p][JPSC].mp4 # 输出：/volume1/Video/watch/夏日重现/s1/夏日重现 - S01E05.mp4 做种问题 qb 的「Torrent 完成时运行外部程序」功能，会在下载完资源的时候，立刻去执行程序，也就是说在下载完之后，我们的文件会被立刻重命名，这导致了我们做种会出现问题，因此我们无法做到下载后再把这个资源分享给其他人。目前也没有好的方式解决。可以考虑不是呀 qb 的这个功能，直接定时任务去执行程序，扫描固定的目录来重命名。\n","date":"2022-05-15T00:00:00Z","image":"https://cdn.jsdelivr.net/gh/shelken/picbed/uPic/2023-11/0sko2h.jpg","permalink":"https://blog.ooooo.space/p/%E8%A7%A3%E5%86%B3%E5%AD%97%E5%B9%95%E7%BB%84%E5%91%BD%E5%90%8D%E4%B8%8D%E8%A7%84%E8%8C%83%E9%97%AE%E9%A2%98%E4%BD%BF%E7%94%A8episode-rename%E5%B7%A5%E5%85%B7/","title":"解决字幕组命名不规范问题：使用Episode-ReName工具"},{"content":"材料 qBittorrent（wiki）（以下简称 qb） 支持 rss 订阅的种子站（e.g. nyaa(wiki)） 实现 打开 qb 配置页面，我的是部署在群晖的 qb，因此使用 web 页面来管理；如果是程序也一样。将启用 rss 订阅打开，间隔与数目最大值根据自定，然后将下面的「自动下载」打开，打开后我们才能在 rss 订阅更新时自动下载你订阅的资源。\n然后点右侧的 「RSS」\n然后我们先离开一下 qb，去你需要订阅资源的 bt 下载站。这里以我自己的需求做演示，我们来到「nyaa」;\n首先，我确定了我需要的订阅的内容：是喵萌奶茶屋字幕组翻译的夏日重现，并只要 1080p 的资源内容。这里我搜索「喵萌奶茶屋 夏日重现 1080p」，可以看到结果非常符合我的预期。因为字幕组的命名基本是固定的，所以这个搜索结果基本是稳定的。\n点击 RSS\n可以看到地址 url 变了，因此我们知道，只要在原来的内容加上page=rss，那么就拿到我们的 rss 订阅地址\n1 2 3 4 5 原 url： https://nyaa.si/?f=0\u0026amp;c=0_0\u0026amp;q=%E5%96%B5%E8%90%8C%E5%A5%B6%E8%8C%B6%E5%B1%8B+%E5%A4%8F%E6%97%A5%E9%87%8D%E7%8E%B0+1080p 新 url: https://nyaa.si/?c=0_0\u0026amp;f=0\u0026amp;q=%E5%96%B5%E8%90%8C%E5%A5%B6%E8%8C%B6%E5%B1%8B+%E5%A4%8F%E6%97%A5%E9%87%8D%E7%8E%B0+1080p\u0026amp;page=rss 回到 qb 界面，订阅 rss\n然后打开rss下载器，新建一个下载规则；这里我讲解一下规则定义。\n空格代表与关系，即这些关键词都必须有才匹配上。|代表或关系，即只要有一个关键词命中就匹配，?代表一个字符，*代表 0 或多个字符。这里我们甚至可以使用正则表达式，能实现更加复杂的限制。\n这里我的必须包含则进一步限制当前规则的下匹配资源的条件。必须不含里的合集则是考虑到字幕组会在番剧结束后打包一个合集目录，一次我们把带有合集字样的资源排除掉。由于我之前下载过这些剧集，因此我把 1-3 的内容也排除掉。剧集过滤器在这里是没用的，因为大部分番剧字幕组没有按照欧美剧集的格式来命名（形如：S01E01）。因此这里没有作用。分类与保存目录可以自定义。可能你的每个规则对应多个 rss 订阅，也可以只对应一个 rss 订阅，这里完全看自己习惯和方式，添加后不开始下载这里我选择从不，这样会关联规则和订阅后，自动下载未下载过的匹配的订阅资源。布局按全局就行，不是那么重要。\n然后将你配置好的规则和你订阅的RSS链接进行关联，保存\n至此，你的 qb 每隔 xx 分钟去刷新订阅，当有新资源发布在种子网站时，qb 会自动下载符合你定义的资源，并保存在你定义的目录下。\n","date":"2022-05-14T00:00:00Z","image":"https://cdn.jsdelivr.net/gh/shelken/picbed/uPic/2023-11/TrVKhx.png","permalink":"https://blog.ooooo.space/p/qbittorrent%E7%9A%84rss%E8%AE%A2%E9%98%85%E4%B8%8B%E8%BD%BD%E6%8C%87%E5%8D%97/","title":"qBittorrent的RSS订阅下载指南"},{"content":"声明 不提供涉及 APP 的下载及其他使用教程\n前提 知道 QuanX 的基本使用逻辑，以及基本的概念 有自我修改部分代码能力和上 github 或者其他托管代码平台的能力 学习资源来源 脚本原作者仓库 Bili_Auto_Region 脚本 效果 效果 1 进入 B 站客户端 进入『首页』，点击『追番』 找到番剧『进击的巨人最终季』 点击进入，脚本会自动将代理节点切换设置的代理分组 如果出现『找不到页面』，点击页面的『重新加载』或刷新页面，进入番剧观看页面，正常观看 退出观看页，脚本自动切换为直连 效果 2 进入 B 站客户端 点击『输入框』 输入『进击的巨人 港』 脚本自动切换代理分组 页面显示『进击的巨人』番剧结果 点击『立即观看』，进入观看页 优点 不用再每次看港澳台番剧时自己手动切成全局，看完后又切换回规则模式，全自动。 实践 准备 带有 ios 系统的 iPhone 一个 QuanX App 『Bili_Auto_Region 脚本』 修改原有脚本 到『脚本原作者仓库』，fork 该仓库\n加入『StreamingSE』规则集（必须）\n1 2 # 绑定相关select或static策略组，并且需要具有相关的区域代理服务器纳入您的子策略中，子策略可以是服务器也可以是其他区域策略组． https://raw.githubusercontent.com/DivineEngine/Profiles/master/Quantumult/Filter/StreamingMedia/StreamingSE.list 设置该规则集的『策略偏好』为自己的『父策略组』（例如我设为 『BiliGroup』）\n添加几个子策略组（如台湾 or 香港）（这里涉及到策略组的节点选择策略，自己了解）\n修改 Surge/JS/Bili_Auto_Regions.js，提交更改\n1 2 3 4 5 6 7 8 //找到如下代码块，删除如下中文，修改成自己创建的策略组名 const Group = $.read(\u0026#39;BiliArea_Policy\u0026#39;) || \u0026#39;你的父策略组（BiliGroup）\u0026#39;; //Your blibli policy group name. const CN = $.read(\u0026#39;BiliArea_CN\u0026#39;) || \u0026#39;DIRECT\u0026#39;; //Your China sub-policy name. const TW = $.read(\u0026#39;BiliArea_TW\u0026#39;) || \u0026#39;台湾子策略组\u0026#39;; //Your Taiwan sub-policy name. const HK = $.read(\u0026#39;BiliArea_HK\u0026#39;) || \u0026#39;香港子策略组\u0026#39;; //Your HongKong sub-policy name. const DF = $.read(\u0026#39;BiliArea_DF\u0026#39;) || \u0026#39;请求失败后的策略组\u0026#39;; //Sub-policy name used after region is blocked(e.g. url 404) const off = $.read(\u0026#39;BiliArea_disabled\u0026#39;) || \u0026#39;在某些wifi下不转换策略组\u0026#39;; //WiFi blacklist(disable region change), separated by commas. const current = await $.getPolicy(Group); 在 QuantumultX/ 目录下（或其他目录），新增两个文件，一个『分流』，一个『重写』，举例：\n1 2 3 4 5 6 7 8 9 10 11 12 #『重写』引用：Bili_Region.conf # start------------- hostname = ap?.bilibili.com, ap?.biliapi.net ^https:\\/\\/ap(p|i)\\.bili(bili|api)\\.(com|net)\\/(pgc\\/view\\/v\\d\\/app\\/season|x\\/v\\d\\/search\\/defaultwords)\\?access_key url script-response-body https://raw.githubusercontent.com/你的用户名/Script/master/Surge/JS/Bili_Auto_Regions.js # 适用于搜索指定地区的番剧（该脚本为『效果2』的实现，根据自身需要选择） ^https:\\/\\/ap(p|i)\\.bili(bili|api)\\.(com|net)\\/x\\/v\\d\\/search(\\/type)?\\?.+?%20(%E6%B8%AF|%E5%8F%B0|%E4%B8%AD)\u0026amp; url script-request-header https://raw.githubusercontent.com/你的用户名/Script/master/Surge/JS/Bili_Auto_Regions.js # end-------------- #『分流』引用：Bili_Region.list # start----------------- ip-cidr, 203.107.1.1/24, reject # end-------------------- 打开 App；将以上两个文件『分流』与『重写』分别引用；\n最后，在 QuanX -\u0026gt; 其他设置 -\u0026gt; VPN 中，关闭 MPM（温和策略机制）\n至此，所有需要做的都已经完成，此时，进入 B 站客户端，实现以上的效果\nWhy？ 为什么？这部分将对『实践』中的部分操作做解释。\n为什么 fork 仓库？\n1 因为需要修改原脚本相关分组的名字，这部分由自己定义；而且涉及到『重写』与『分流』引用，虽然不是必须，但是强烈建议这样做；可以方便地管理这些规则的开关； 为什么关闭 MPM\n1 主要是在切换策略时打断之前的连接，让策略生效（个人认为） 已知问题 在长时间使用 B 站一段时间后，会发现脚本有失效情况，这个时候退出 B 站重新进入可以解决。 最后 如果有代码方面的时候问题，请到原作者脚本仓库上提 issue。\n如果有关于以上实践部分的问题，可以在下方评论提问。本教程也是参考了原脚本的注释部分，自己实践得来，建议在问之前把注释看一遍；不提供除实践部分之外的问题。如果是我知道的，我会提供关键词给你，然后请自己去问谷歌。\n","date":"2022-04-01T00:00:00Z","image":"https://cdn.jsdelivr.net/gh/shelken/picbed/PicGo/2023-11/bcff2d81.jpg","permalink":"https://blog.ooooo.space/p/%E4%BC%98%E9%9B%85%E8%A7%82%E7%9C%8B%E6%96%B0%E7%95%AAb%E7%AB%99%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"优雅观看新番：B站客户端使用指南"}]